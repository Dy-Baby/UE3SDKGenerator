#include "PiecesOfCode.hpp"

/*
# ========================================================================================= #
# Pieces Of Code
# ========================================================================================= #
*/

namespace PiecesOfCode
{
	const std::string TArray_Iterator =
		"template<typename TArray>\n"
		"class TIterator\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = typename TArray::ElementType;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\tusing ElementReference = ElementType&;\n"
		"\tusing ElementConstReference = const ElementType&;\n"
		"\n"
		"private:\n"
		"\tElementPointer IteratorData;\n"
		"\n"
		"public:\n"
		"\tTIterator(ElementPointer inElementPointer)\n"
		"\t{\n"
		"\t\tIteratorData = inElementPointer;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tTIterator& operator++()\n"
		"\t{\n"
		"\t\tIteratorData++;\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\tTIterator operator++(int32_t)\n"
		"\t{\n"
		"\t\tTIterator iteratorCopy = *this;\n"
		"\t\t++(*this);\n"
		"\t\treturn iteratorCopy;\n"
		"\t}\n"
		"\n"
		"\tTIterator& operator--()\n"
		"\t{\n"
		"\t\tIteratorData--;\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\tTIterator operator--(int32_t)\n"
		"\t{\n"
		"\t\tTIterator iteratorCopy = *this;\n"
		"\t\t--(*this);\n"
		"\t\treturn iteratorCopy;\n"
		"\t}\n"
		"\n"
		"\tElementReference operator[](int32_t index)\n"
		"\t{\n"
		"\t\treturn *(IteratorData[index]);\n"
		"\t}\n"
		"\n"
		"\tElementPointer operator->()\n"
		"\t{\n"
		"\t\treturn IteratorData;\n"
		"\t}\n"
		"\n"
		"\tElementReference operator*()\n"
		"\t{\n"
		"\t\treturn *IteratorData;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tbool operator==(const TIterator& other) const\n"
		"\t{\n"
		"\t\treturn (IteratorData == other.IteratorData);\n"
		"\t}\n"
		"\n"
		"\tbool operator!=(const TIterator& other) const\n"
		"\t{\n"
		"\t\treturn !(*this == other);\n"
		"\t}\n"
		"};\n";

	const std::string TArray_Class =
		"template<typename InElementType>\n"
		"class TArray\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = InElementType;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\tusing ElementReference = ElementType&;\n"
		"\tusing ElementConstReference = const ElementType&;\n"
		"\tusing Iterator = TIterator<TArray<ElementType>>;\n"
		"\n"
		"private:\n"
		"\tElementPointer ArrayData;\n"
		"\tint32_t ArrayCount;\n"
		"\tint32_t ArrayMax;\n"
		"\n"
		"public:\n"
		"\tTArray()\n"
		"\t{\n"
		"\t\tArrayData = nullptr;\n"
		"\t\tArrayCount = 0;\n"
		"\t\tArrayMax = 0;\n"
		"\n"
		"\t\t//ReAllocate(sizeof(ElementType));\n"
		"\t}\n"
		"\n"
		"\t~TArray()\n"
		"\t{\n"
		"\t\t//Clear();\n"
		"\t\t//::operator delete(ArrayData, ArrayMax * sizeof(ElementType));\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tElementConstReference operator[](int32_t index) const\n"
		"\t{\n"
		"\t\tif (index <= ArrayCount)\n"
		"\t\t{\n"
		"\t\t\treturn ArrayData[index];\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tElementReference operator[](int32_t index)\n"
		"\t{\n"
		"\t\tif (index <= ArrayCount)\n"
		"\t\t{\n"
		"\t\t\treturn ArrayData[index];\n"
		"\t\t} \n"
		"\t}\n"
		"\n"
		"\tElementConstReference At(int32_t index) const\n"
		"\t{\n"
		"\t\tif (index <= ArrayCount)\n"
		"\t\t{\n"
		"\t\t\treturn ArrayData[index];\n"
		"\t\t} \n"
		"\t}\n"
		"\n"
		"\tElementReference At(int32_t index)\n"
		"\t{\n"
		"\t\tif (index <= ArrayCount)\n"
		"\t\t{\n"
		"\t\t\treturn ArrayData[index];\n"
		"\t\t} \n"
		"\t}\n"
		"\n"
		"\tvoid Add(ElementConstReference newElement)\n"
		"\t{\n"
		"\t\tif (ArrayCount >= ArrayMax)\n"
		"\t\t{\n"
		"\t\t\tReAllocate(sizeof(ElementType) * (ArrayCount + 1));\n"
		"\t\t}\n"
		"\n"
		"\t\tnew(&ArrayData[ArrayCount]) ElementType(newElement);\n"
		"\t\tArrayCount++;\n"
		"\t}\n"
		"\n"
		"\tvoid Add(ElementReference& newElement)\n"
		"\t{\n"
		"\t\tif (ArrayCount >= ArrayMax)\n"
		"\t\t{\n"
		"\t\t\tReAllocate(sizeof(ElementType) * (ArrayCount + 1));\n"
		"\t\t}\n"
		"\n"
		"\t\tnew(&ArrayData[ArrayCount]) ElementType(newElement);\n"
		"\t\tArrayCount++;\n"
		"\t}\n"
		"\n"
		"\tvoid PopBack()\n"
		"\t{\n"
		"\t\tif (ArrayCount > 0)\n"
		"\t\t{\n"
		"\t\t\tArrayCount--;\n"
		"\t\t\tArrayData[ArrayCount].~ElementType();\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tvoid Clear()\n"
		"\t{\n"
		"\t\tfor (int32_t i = 0; i < ArrayCount; i++)\n"
		"\t\t{\n"
		"\t\t\tArrayData[i].~ElementType();\n"
		"\t\t}\n"
		"\n"
		"\t\tArrayCount = 0;\n"
		"\t}\n"
		"\n"
		"\tint32_t Num() const\n"
		"\t{\n"
		"\t\treturn ArrayCount;\n"
		"\t}\n"
		"\n"
		"\tint32_t Max() const\n"
		"\t{\n"
		"\t\treturn ArrayMax;\n"
		"\t}\n"
		"\n"
		"\tIterator begin()\n"
		"\t{\n"
		"\t\treturn Iterator(ArrayData);\n"
		"\t}\n"
		"\n"
		"\tIterator end()\n"
		"\t{\n"
		"\t\treturn Iterator(ArrayData + ArrayCount);\n"
		"\t}\n"
		"\n"
		"private:\n"
		"\tvoid ReAllocate(int32_t newArrayMax)\n"
		"\t{\n"
		"\t\tElementPointer newArrayData = (ElementPointer)::operator new(newArrayMax * sizeof(ElementType));\n"
		"\n"
		"\t\tint32_t newNum = ArrayCount;\n"
		"\n"
		"\t\tif (newArrayMax < newNum)\n"
		"\t\t{\n"
		"\t\t\tnewNum = newArrayMax;\n"
		"\t\t}\n"
		"\n"
		"\t\tfor (int32_t i = 0; i < newNum; i++)\n"
		"\t\t{\n"
		"\t\t\tnew(newArrayData + i) ElementType(std::move(ArrayData[i]));\n"
		"\t\t}\n"
		"\n"
		"\t\tfor (int32_t i = 0; i < ArrayCount; i++)\n"
		"\t\t{\n"
		"\t\t\tArrayData[i].~ElementType();\n"
		"\t\t}\n"
		"\n"
		"\t\t::operator delete(ArrayData, ArrayMax * sizeof(ElementType));\n"
		"\t\tArrayData = newArrayData;\n"
		"\t\tArrayMax = newArrayMax;\n"
		"\t}\n"
		"};\n";

	const std::string TMap_Class =
		"template<typename TKey, typename TValue>\n"
		"class TMap\n"
		"{\n"
		"private:\n"
		"\tclass TPair\n"
		"\t{\n"
		"\t\tTKey Key;\n"
		"\t\tTValue Value;\n"
		"\t\tint32_t* HashNext;\n"
		"\t};\n"
		"\n"
		"public:\n"
		"\tusing ElementType = TPair;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\tusing ElementReference = ElementType&;\n"
		"\tusing ElementConstReference = const ElementType&;\n"
		"\tusing Iterator = TIterator<TMap<TKey, TValue>>;\n"
		"\n"
		"public:\n"
		"\tElementPointer ElementData; // 0x0000 (0x0008)\n"
		"\tint32_t ElementCount; // 0x0008 (0x0004)\n"
		"\tint32_t ElementMax; // 0x000C (0x0004)\n"
		"\tuintptr_t IndirectData; // 0x0010 (0x0008)\n"
		"\tint32_t InlineData[0x4]; // 0x0018 (0x0010)\n"
		"\tint32_t NumBits; // 0x0028 (0x0004)\n"
		"\tint32_t MaxBits; // 0x002C (0x0004)\n"
		"\tint32_t FirstFreeIndex; // 0x0030 (0x0004)\n"
		"\tint32_t NumFreeIndices; // 0x0034 (0x0004)\n"
		"\tint64_t InlineHash; // 0x0038 (0x0008)\n"
		"\tint32_t* Hash; // 0x0040 (0x0008)\n"
		"\tint32_t HashCount; // 0x0048 (0x0004)\n"
		"\n"
		"public:\n"
		"\tTMap()\n"
		"\t{\n"
		"\t\tElementData = nullptr;\n"
		"\t\tElementCount = 0;\n"
		"\t\tElementMax = 0;\n"
		"\t\tIndirectData = NULL;\n"
		"\t\tNumBits = 0;\n"
		"\t\tMaxBits = 0;\n"
		"\t\tFirstFreeIndex = 0;\n"
		"\t\tNumFreeIndices = 0;\n"
		"\t\tInlineHash = 0;\n"
		"\t\tHash = nullptr;\n"
		"\t\tHashCount = 0;\n"
		"\t}\n"
		"\n"
		"\tTMap(struct FMap_Mirror& fMap)\n"
		"\t{\n"
		"\t\t*this = *reinterpret_cast<TMap<TKey, TValue>*>(&fMap);\n"
		"\t}\n"
		"\n"
		"\t~TMap() { }\n"
		"\n"
		"public:\n"
		"\tElementConstReference operator[](const int32_t index) const\n"
		"\t{\n"
		"\t\tif (index <= ElementCount)\n"
		"\t\t{\n"
		"\t\t\treturn ElementData[index];\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tElementReference operator[](const int32_t index)\n"
		"\t{\n"
		"\t\tif (index <= ElementCount)\n"
		"\t\t{\n"
		"\t\t\treturn ElementData[index];\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tconst TValue& operator[](const TKey key) const\n"
		"\t{\n"
		"\t\tfor (int32_t i = 0; i < Num(); i++)\n"
		"\t\t{\n"
		"\t\t\tconst TPair& pair = ElementData[i];\n"
		"\n"
		"\t\t\tif (pair.Key == key)\n"
		"\t\t\t{\n"
		"\t\t\t\treturn pair.Value;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tTValue& operator[](const TKey key)\n"
		"\t{\n"
		"\t\tfor (int32_t i = 0; i < Num(); i++)\n"
		"\t\t{\n"
		"\t\t\tTPair& pair = ElementData[i];\n"
		"\n"
		"\t\t\tif (pair.Key == key)\n"
		"\t\t\t{\n"
		"\t\t\t\treturn pair.Value;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tTMap<TKey, TValue> operator=(const struct FMap_Mirror& fMap)\n"
		"\t{\n"
		"\t\t*this = *reinterpret_cast<TMap<TKey, TValue>*>(&fMap);\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\tElementConstReference At(const int32_t index) const\n"
		"\t{\n"
		"\t\tif (index <= ElementCount)\n"
		"\t\t{\n"
		"\t\t\treturn ElementData[index];\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tElementReference At(const int32_t index)\n"
		"\t{\n"
		"\t\tif (index <= ElementCount)\n"
		"\t\t{\n"
		"\t\t\treturn ElementData[index];\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\tint32_t Num() const\n"
		"\t{\n"
		"\t\treturn ElementCount;\n"
		"\t}\n"
		"\n"
		"\tint32_t Max() const\n"
		"\t{\n"
		"\t\treturn ElementMax;\n"
		"\t}\n"
		"\n"
		"\tIterator begin()\n"
		"\t{\n"
		"\t\treturn Iterator(ElementData);\n"
		"\t}\n"
		"\n"
		"\tIterator end()\n"
		"\t{\n"
		"\t\treturn Iterator(ElementData + ElementCount);\n"
		"\t}\n"
		"};\n";

	const std::string FNameEntry_UPPER =
		"struct FNameEntry\n"
		"{\n"
		"public:\n";

	const std::string FNameEntry_UTF16 =
		"\n"
		"public:\n"
		"\tint32_t GetIndex() const\n"
		"\t{\n"
		"\t\treturn Index;\n"
		"\t}\n"
		"\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\tstd::wstring ws(Name);\n"
		"\t\tstd::string str(ws.begin(), ws.end());\n"
		"\t\treturn str;\n"
		"\t}\n"
		"\n"
		"\tconst wchar_t* GetWideName() const\n"
		"\t{\n"
		"\t\treturn Name;\n"
		"\t}\n"
		"};\n";

	const std::string FNameEntry_UTF8 =
		"\n"
		"public:\n"
		"\tint32_t GetIndex() const\n"
		"\t{\n"
		"\t\treturn Index;\n"
		"\t}\n"
		"\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\treturn std::string(Name);\n"
		"\t}\n"
		"\n"
		"\tconst char* GetAnsiName() const\n"
		"\t{\n"
		"\t\treturn Name;\n"
		"\t}\n";

	const std::string FName_UTF16 =
		"struct FName\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = const wchar_t;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\n"
		"private:\n"
		"\tint32_t\t\t\tFNameEntryId;\t\t\t\t\t\t\t\t\t// 0x0000 (0x04)\n"
		"\tint32_t\t\t\tInstanceNumber;\t\t\t\t\t\t\t\t\t// 0x0004 (0x04)\n"
		"\n"
		"public:\n"
		"\tFName()\n"
		"\t{\n"
		"\t\tFNameEntryId = 0;\n"
		"\t\tInstanceNumber = 0;\n"
		"\t}\n"
		"\n"
		"\tFName(const int32_t id)\n"
		"\t{\n"
		"\t\tFNameEntryId = id;\n"
		"\t\tInstanceNumber = 0;\n"
		"\t}\n"
		"\n"
		"\tFName(const ElementPointer nameToFind)\n"
		"\t{\n"
		"\t\tstatic std::vector<int32_t> nameCache{};\n"
		"\n"
		"\t\tFNameEntryId = 0;\n"
		"\t\tInstanceNumber = 0;\n"
		"\n"
		"\t\tfor (int32_t entryId : nameCache)\n"
		"\t\t{\n"
		"\t\t\tif (Names()->At(entryId))\n"
		"\t\t\t{\n"
		"\t\t\t\tif (!wcscmp(Names()->At(entryId)->Name, nameToFind))\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tFNameEntryId = entryId;\n"
		"\t\t\t\t\treturn;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\tfor (int32_t i = 0; i < Names()->Num(); i++)\n"
		"\t\t{\n"
		"\t\t\tif (Names()->At(i))\n"
		"\t\t\t{\n"
		"\t\t\t\tif (!wcscmp(Names()->At(i)->Name, nameToFind))\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tnameCache.push_back(i);\n"
		"\t\t\t\t\tFNameEntryId = i;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t~FName() { }\n"
		"\n"
		"public:\n"
		"\tstatic class TArray<struct FNameEntry*>* Names()\n"
		"\t{\n"
		"\t\tTArray<FNameEntry*>* GNamesArray = reinterpret_cast<TArray<FNameEntry*>*>(GNames);\n"
		"\t\treturn GNamesArray;\n"
		"\t}\n"
		"\n"
		"\tint32_t GetDisplayIndex() const\n"
		"\t{\n"
		"\t\treturn FNameEntryId;\n"
		"\t}\n"
		"\n"
		"\tconst struct FNameEntry GetDisplayNameEntry() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn *Names()->At(FNameEntryId);\n"
		"\t\t}\n"
		"\n"
		"\t\treturn FNameEntry();\n"
		"\t}\n"
		"\n"
		"\tstruct FNameEntry* GetEntry()\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn Names()->At(FNameEntryId);\n"
		"\t\t}\n"
		"\n"
		"\t\treturn nullptr;\n"
		"\t}\n"
		"\n"
		"\tint32_t GetNumber() const\n"
		"\t{\n"
		"\t\treturn InstanceNumber;\n"
		"\t}\n"
		"\n"
		"\tvoid SetNumber(int32_t newNumber)\n"
		"\t{\n"
		"\t\tInstanceNumber = newNumber;\n"
		"\t}\n"
		"\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn GetDisplayNameEntry().ToString();\n"
		"\t\t}\n"
		"\n"
		"\t\treturn std::string(\"UnknownName\");\n"
		"\t}\n"
		"\n"
		"\tbool IsValid() const\n"
		"\t{\n"
		"\t\tif (FNameEntryId < 0 || FNameEntryId > Names()->Num())\n"
		"\t\t{\n"
		"\t\t\treturn false;\n"
		"\t\t}\n"
		"\n"
		"\t\treturn true;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tstruct FName operator=(const struct FName& other)\n"
		"\t{\n"
		"\t\tFNameEntryId = other.FNameEntryId;\n"
		"\t\tInstanceNumber = other.InstanceNumber;\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\tbool operator==(const struct FName& other) const\n"
		"\t{\n"
		"\t\treturn (FNameEntryId == other.FNameEntryId);\n"
		"\t}\n"
		"\n"
		"\tbool operator!=(const struct FName& other) const\n"
		"\t{\n"
		"\t\treturn (FNameEntryId != other.FNameEntryId);\n"
		"\t}\n"
		"};\n";

	const std::string FName_UTF8 =
		"struct FName\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = const char;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\n"
		"private:\n"
		"\tint32_t\t\t\tFNameEntryId;\t\t\t\t\t\t\t\t\t// 0x0000 (0x04)\n"
		"\tint32_t\t\t\tInstanceNumber;\t\t\t\t\t\t\t\t\t// 0x0004 (0x04)\n"
		"\n"
		"public:\n"
		"\tFName()\n"
		"\t{\n"
		"\t\tFNameEntryId = 0;\n"
		"\t\tInstanceNumber = 0;\n"
		"\t}\n"
		"\n"
		"\tFName(const int32_t id)\n"
		"\t{\n"
		"\t\tFNameEntryId = id;\n"
		"\t\tInstanceNumber = 0;\n"
		"\t}\n"
		"\n"
		"\tFName(ElementPointer nameToFind)\n"
		"\t{\n"
		"\t\tstatic std::vector<int32_t> nameCache{};\n"
		"\n"
		"\t\tFNameEntryId = 0;\n"
		"\t\tInstanceNumber = 0;\n"
		"\n"
		"\t\tfor (int32_t entryId : nameCache)\n"
		"\t\t{\n"
		"\t\t\tif (Names()->At(entryId))\n"
		"\t\t\t{\n"
		"\t\t\t\tif (!strcmp(Names()->At(entryId)->Name, nameToFind))\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tFNameEntryId = entryId;\n"
		"\t\t\t\t\treturn;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\tfor (int32_t i = 0; i < Names()->Num(); i++)\n"
		"\t\t{\n"
		"\t\t\tif (Names()->At(i))\n"
		"\t\t\t{\n"
		"\t\t\t\tif (!strcmp(Names()->At(i)->Name, nameToFind))\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tnameCache.push_back(i);\n"
		"\t\t\t\t\tFNameEntryId = i;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t~FName() { }\n"
		"\n"
		"public:\n"
		"\tstatic class TArray<struct FNameEntry*>* Names()\n"
		"\t{\n"
		"\t\tTArray<FNameEntry*>* GNamesArray = reinterpret_cast<TArray<FNameEntry*>*>(GNames);\n"
		"\t\treturn GNamesArray;\n"
		"\t}\n"
		"\n"
		"\tint32_t GetDisplayIndex() const\n"
		"\t{\n"
		"\t\treturn FNameEntryId;\n"
		"\t}\n"
		"\n"
		"\tconst struct FNameEntry GetDisplayNameEntry() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn *Names()->At(FNameEntryId);\n"
		"\t\t}\n"
		"\n"
		"\t\treturn FNameEntry();\n"
		"\t}\n"
		"\n"
		"\tstruct FNameEntry* GetEntry()\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn Names()->At(FNameEntryId);\n"
		"\t\t}\n"
		"\n"
		"\t\treturn nullptr;\n"
		"\t}\n"
		"\n"
		"\tint32_t GetNumber() const\n"
		"\t{\n"
		"\t\treturn InstanceNumber;\n"
		"\t}\n"
		"\n"
		"\tvoid SetNumber(const int32_t& newNumber)\n"
		"\t{\n"
		"\t\tInstanceNumber = newNumber;\n"
		"\t}\n"
		"\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn GetDisplayNameEntry().ToString();\n"
		"\t\t}\n"
		"\n"
		"\t\treturn std::string(\"UnknownName\");\n"
		"\t}\n"
		"\n"
		"\tbool IsValid() const\n"
		"\t{\n"
		"\t\tif (FNameEntryId < 0 || FNameEntryId > Names()->Num())\n"
		"\t\t{\n"
		"\t\t\treturn false;\n"
		"\t\t}\n"
		"\n"
		"\t\treturn true;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tstruct FName operator=(const struct FName& other)\n"
		"\t{\n"
		"\t\tFNameEntryId = other.FNameEntryId;\n"
		"\t\tInstanceNumber = other.InstanceNumber;\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\tbool operator==(const struct FName& other) const\n"
		"\t{\n"
		"\t\treturn (FNameEntryId == other.FNameEntryId);\n"
		"\t}\n"
		"\n"
		"\tbool operator!=(const struct FName& other) const\n"
		"\t{\n"
		"\t\treturn (FNameEntryId != other.FNameEntryId);\n"
		"\t}\n"
		"};\n";

	const std::string FString_UTF16 =
		"class FString\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = const wchar_t;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\n"
		"private:\n"
		"\tElementPointer\tArrayData;\t\t\t\t\t\t\t\t\t\t// 0x0000 (0x08)\n"
		"\tint32_t\t\t\tArrayCount;\t\t\t\t\t\t\t\t\t\t// 0x0008 (0x04)\n"
		"\tint32_t\t\t\tArrayMax;\t\t\t\t\t\t\t\t\t\t// 0x000C (0x04)\n"
		"\n"
		"public:\n"
		"\tFString()\n"
		"\t{\n"
		"\t\tArrayData = nullptr;\n"
		"\t\tArrayCount = 0;\n"
		"\t\tArrayMax = 0;\n"
		"\t}\n"
		"\n"
		"\tFString(ElementPointer other)\n"
		"\t{\n"
		"\t\tArrayData = nullptr;\n"
		"\t\tArrayCount = 0;\n"
		"\t\tArrayMax = 0;\n"
		"\n"
		"\t\tArrayMax = ArrayCount = *other ? (wcslen(other) + 1) : 0;\n"
		"\n"
		"\t\tif (ArrayCount > 0)\n"
		"\t\t{\n"
		"\t\t\tArrayData = other;\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t~FString() { }\n"
		"\n"
		"public:\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\tstd::wstring wideStr(ArrayData);\n"
		"\t\t\tstd::string str(wideStr.begin(), wideStr.end());\n"
		"\t\t\treturn str;\n"
		"\t\t}\n"
		"\n"
		"\t\treturn std::string(\"null\");\n"
		"\t}\n"
		"\n"
		"\tbool IsValid() const\n"
		"\t{\n"
		"\t\treturn !!ArrayData;\n"
		"\t}\n"
		"\n"
		"\tFString operator=(ElementPointer other)\n"
		"\t{\n"
		"\t\tif (ArrayData != other)\n"
		"\t\t{\n"
		"\t\t\tArrayMax = ArrayCount = *other ? (wcslen(other) + 1) : 0;\n"
		"\n"
		"\t\t\tif (ArrayCount > 0)\n"
		"\t\t\t{\n"
		"\t\t\t\tArrayData = other;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tbool operator==(const FString& other)\n"
		"\t{\n"
		"\t\treturn (!wcscmp(ArrayData, other.ArrayData));\n"
		"\t}\n"
		"\n"
		"\tbool operator!=(const FString& other)\n"
		"\t{\n"
		"\t\treturn (wcscmp(ArrayData, other.ArrayData));\n"
		"\t}\n"
		"};\n";

	const std::string FString_UTF8 =
		"class FString\n"
		"{\n"
		"public:\n"
		"\tusing ElementType = const char;\n"
		"\tusing ElementPointer = ElementType*;\n"
		"\n"
		"private:\n"
		"\tElementPointer\tArrayData;\t\t\t\t\t\t\t\t\t\t// 0x0000 (0x08)\n"
		"\tint32_t\t\t\tArrayCount;\t\t\t\t\t\t\t\t\t\t// 0x0008 (0x04)\n"
		"\tint32_t\t\t\tArrayMax;\t\t\t\t\t\t\t\t\t\t// 0x000C (0x04)\n"
		"\n"
		"public:\n"
		"\tFString()\n"
		"\t{\n"
		"\t\tArrayData = nullptr;\n"
		"\t\tArrayCount = 0;\n"
		"\t\tArrayMax = 0;\n"
		"\t}\n"
		"\n"
		"\tFString(ElementPointer other)\n"
		"\t{\n"
		"\t\tArrayData = nullptr;\n"
		"\t\tArrayCount = 0;\n"
		"\t\tArrayMax = 0;\n"
		"\n"
		"\t\tArrayMax = ArrayCount = *other ? (strlen(other) + 1) : 0;\n"
		"\n"
		"\t\tif (ArrayCount > 0)\n"
		"\t\t{\n"
		"\t\t\tArrayData = other;\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t~FString() { }\n"
		"\n"
		"public:\n"
		"\tstd::string ToString() const\n"
		"\t{\n"
		"\t\tif (IsValid())\n"
		"\t\t{\n"
		"\t\t\treturn std::string(ArrayData);\n"
		"\t\t}\n"
		"\n"
		"\t\treturn std::string(\"null\");\n"
		"\t}\n"
		"\n"
		"\tbool IsValid() const\n"
		"\t{\n"
		"\t\treturn !!ArrayData;\n"
		"\t}\n"
		"\n"
		"\tFString operator=(ElementPointer other)\n"
		"\t{\n"
		"\t\tif (ArrayData != other)\n"
		"\t\t{\n"
		"\t\t\tArrayMax = ArrayCount = *other ? (strlen(other) + 1) : 0;\n"
		"\n"
		"\t\t\tif (ArrayCount > 0)\n"
		"\t\t\t{\n"
		"\t\t\t\tArrayData = other;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"public:\n"
		"\tbool operator==(const FString& other)\n"
		"\t{\n"
		"\t\treturn (!strcmp(ArrayData, other.ArrayData));\n"
		"\t}\n"
		"\n"
		"\tbool operator!=(const FString& other)\n"
		"\t{\n"
		"\t\treturn (strcmp(ArrayData, other.ArrayData));\n"
		"\t}\n"
		"};\n";

	const std::string FPointer_Struct =
		"struct FPointer\n"
		"{\n"
		"\tuintptr_t Dummy;\n"
		"};\n";

	const std::string FQWord_Struct =
		"struct FQWord\n"
		"{\n"
		"\tint32_t A;\n"
		"\tint32_t B;\n"
		"};\n";

	const std::string UObject_FunctionDescriptions =
		"\tstatic TArray<class UObject*>* GObjObjects();\n"
		"\n"
		"\tstd::string GetName();\n"
		"\tstd::string GetNameCPP();\n"
		"\tstd::string GetFullName();\n"
		"\tstd::string GetPackageName();\n"
		"\tclass UObject* GetPackageObj();\n"
		"\ttemplate<typename T> static T* FindObject(const std::string& objectFullName)\n"
		"\t{\n"
		"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
		"\t\t{\n"
		"\t\t\tif (uObject && uObject->IsA(T::StaticClass()))\n"
		"\t\t\t{\n"
		"\t\t\t\tif (uObject->GetFullName() == objectFullName)\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\treturn reinterpret_cast<T*>(uObject);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\treturn nullptr;\n"
		"\t}\n"
		"\ttemplate<typename T> static uint32_t CountObject(const std::string& objectName)\n"
		"\t{\n"
		"\t\tstatic std::map<std::string, int32_t> countCache;\n"
		"\n"
		"\t\tif (countCache.find(objectName) == countCache.end())\n"
		"\t\t{\n"
		"\t\t\tcountCache[objectName] = 0;\n"
		"\n"
		"\t\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
		"\t\t\t{\n"
		"\t\t\t\tif (uObject && uObject->IsA(T::StaticClass()))\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tif (uObject->GetName() == objectName)\n"
		"\t\t\t\t\t{\n"
		"\t\t\t\t\t\tcountCache[uObject->GetName()]++;\n"
		"\t\t\t\t\t}\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\treturn countCache[objectName];\n"
		"\t}\n"
		"\tstatic class UClass* FindClass(const std::string& classFullName);\n"
		"\tbool IsA(class UClass* uClass);\n"
		"\tbool IsA(int objInternalInteger);\n\n";

	const std::string UObject_Functions =
		"TArray<class UObject*>* UObject::GObjObjects()\n"
		"{\n"
		"\tTArray<UObject*>* objectArray = reinterpret_cast<TArray<UObject*>*>(GObjects);\n"
		"\treturn objectArray;\n"
		"}\n"
		"\n"
		"const std::string UObject::GetName()\n"
		"{\n"
		"\treturn this->Name.ToString();\n"
		"}\n"
		"\n"
		"const std::string UObject::GetNameCPP()\n"
		"{\n"
		"\tconst std::string nameCPP;\n"
		"\n"
		"\tif (this->IsA(UClass::StaticClass()))\n"
		"\t{\n"
		"\t\tUClass* uClass = reinterpret_cast<UClass*>(this);\n"
		"\n"
		"\t\twhile (uClass)\n"
		"\t\t{\n"
		"\t\t\tconst std::string className = uClass->GetName();\n"
		"\n"
		"\t\t\tif (className == \"Actor\")\n"
		"\t\t\t{\n"
		"\t\t\t\tnameCPP += \"A\";\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\t\t\telse if (className == \"Object\")\n"
		"\t\t\t{\n"
		"\t\t\t\tnameCPP += \"U\";\n"
		"\t\t\t\tbreak;\n"
		"\t\t\t}\n"
		"\n"
		"\t\t\tuClass = reinterpret_cast<UClass*>(uClass->SuperField);\n"
		"\t\t}\n"
		"\t}\n"
		"\telse\n"
		"\t{\n"
		"\t\tnameCPP += \"F\";\n"
		"\t}\n"
		"\n"
		"\tnameCPP += this->GetName();\n"
		"\n"
		"\treturn nameCPP;\n"
		"}\n"
		"\n"
		"const std::string UObject::GetFullName()\n"
		"{\n"
		"\tif (this->Class && this->Outer)\n"
		"\t{\n"
		"\t\tconst std::string fullName = this->GetName();\n"
		"\n"
		"\t\tfor (UObject* uOuter = this->Outer; uOuter; uOuter = uOuter->Outer)\n"
		"\t\t{\n"
		"\t\t\tfullName = uOuter->GetName() + \".\" + fullName;\n"
		"\t\t}\n"
		"\n"
		"\t\tfullName = this->Class->GetName() + \" \" + fullName;\n"
		"\n"
		"\t\treturn fullName;\n"
		"\t}\n"
		"\n"
		"\treturn \"null\";\n"
		"}\n"
		"\n"
		"UObject* UObject::GetPackageObj()\n"
		"{\n"
		"\tUObject* uPackage = nullptr;\n"
		"\n"
		"\tfor (UObject* uOuter = this->Outer; uOuter; uOuter = uOuter->Outer)\n"
		"\t{\n"
		"\t\tuPackage = uOuter;\n"
		"\t}\n"
		"\n"
		"\treturn uPackage;\n"
		"}\n"
		"\n"
		"UClass* UObject::FindClass(const const std::string& classFullName)\n"
		"{\n"
		"\tstatic bool initialized = false;\n"
		"\tstatic std::map<const std::string, UClass*> foundClasses{};\n"
		"\n"
		"\tif (!initialized)\n"
		"\t{\n"
		"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
		"\t\t{\n"
		"\t\t\tif (uObject)\n"
		"\t\t\t{\n"
		"\t\t\t\tconst std::string objectFullName = uObject->GetFullName();\n"
		"\n"
		"\t\t\t\tif (objectFullName.find(\"Class\") == 0)\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tfoundClasses[objectFullName] = reinterpret_cast<UClass*>(uObject);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\tinitialized = true;\n"
		"\t}\n"
		"\n"
		"\tif (foundClasses.find(classFullName) != foundClasses.end())\n"
		"\t{\n"
		"\t\treturn foundClasses[classFullName];\n"
		"\t}\n"
		"\n"
		"\treturn nullptr;\n"
		"}\n"
		"\n"
		"bool UObject::IsA(class UClass* uClass)\n"
		"{\n"
		"\tfor (UClass* uSuperClass = this->Class; uSuperClass; uSuperClass = reinterpret_cast<UClass*>(uSuperClass->SuperField))\n"
		"\t{\n"
		"\t\tif (uSuperClass == uClass)\n"
		"\t\t{\n"
		"\t\t\treturn true;\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\treturn false;\n"
		"}\n"
		"\n"
		"bool UObject::IsA(int objInternalInteger)\n"
		"{\n"
		"\tUClass* uClass = UObject::GObjObjects()->At(objInternalInteger)->Class;\n"
		"\n"
		"\tif (uClass)\n"
		"\t{\n"
		"\t\treturn this->IsA(uClass);\n"
		"\t}\n"
		"\n"
		"\treturn false;\n"
		"}\n\n";

	const std::string UFunction_Functions =
		"UFunction* UFunction::FindFunction(const const std::string& functionFullName)\n"
		"{\n"
		"\tstatic bool initialized = false;\n"
		"\tstatic std::map<const std::string, UFunction*> foundFunctions{};\n"
		"\n"
		"\tif (!initialized)\n"
		"\t{\n"
		"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
		"\t\t{\n"
		"\t\t\tif (uObject)\n"
		"\t\t\t{\n"
		"\t\t\t\tconst std::string objectFullName = uObject->GetFullName();\n"
		"\n"
		"\t\t\t\tif (objectFullName.find(\"Function\") == 0)\n"
		"\t\t\t\t{\n"
		"\t\t\t\t\tfoundFunctions[objectFullName] = reinterpret_cast<UFunction*>(uObject);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\n"
		"\t\tinitialized = true;\n"
		"\t}\n"
		"\n"
		"\tif (foundFunctions.find(functionFullName) != foundFunctions.end())\n"
		"\t{\n"
		"\t\treturn foundFunctions[functionFullName];\n"
		"\t}\n"
		"\n"
		"\treturn nullptr;\n"
		"}\n\n";
}

/*
# ========================================================================================= #
#
# ========================================================================================= #
*/